#!/usr/bin/env python3
"""
DNS ë¬¸ì œ ì§„ë‹¨ ë° ìë™ ë³µêµ¬ ìŠ¤í¬ë¦½íŠ¸
WSL, systemd-resolved, ë„¤íŠ¸ì›Œí¬ ì„¤ì • ë“±ì˜ DNS ë¬¸ì œë¥¼ ê°ì§€í•˜ê³  ê°€ëŠ¥í•œ ê²½ìš° ìë™ ë³µêµ¬
"""

import sys
import os
import asyncio
import subprocess
import platform
import shutil
from pathlib import Path
from typing import List, Dict, Any, Optional

# í”„ë¡œì íŠ¸ ë£¨íŠ¸ë¥¼ Python ê²½ë¡œ/ì‘ì—… ë””ë ‰í† ë¦¬ë¡œ ê³ ì •
project_root = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(project_root))
os.chdir(project_root)

from src.utils.dns_health_checker import DNSHealthChecker, diagnose_and_log_dns_issues
from src.utils.structured_logger import get_logger

logger = get_logger("dns_fix")


class DNSProblemFixer:
    """DNS ë¬¸ì œ ìë™ ë³µêµ¬"""

    def __init__(self, dry_run: bool = False):
        self.dry_run = dry_run
        self.checker = DNSHealthChecker()
        self.fixes_applied = []
        self.fixes_failed = []

    async def diagnose_and_fix(self) -> Dict[str, Any]:
        """DNS ë¬¸ì œ ì§„ë‹¨ ë° ë³µêµ¬"""
        logger.info("Starting DNS diagnosis and repair", dry_run=self.dry_run)

        try:
            # ì§„ë‹¨ ìˆ˜í–‰
            diagnosis = await diagnose_and_log_dns_issues()

            if diagnosis["severity"] == "low":
                logger.info("No significant DNS issues detected")
                return {
                    "diagnosis": diagnosis,
                    "fixes_applied": [],
                    "fixes_failed": [],
                    "result": "no_issues"
                }

            # ë³µêµ¬ ì‹œë„
            if not self.dry_run:
                await self._apply_fixes(diagnosis)

                # ë³µêµ¬ í›„ ì¬ì§„ë‹¨
                logger.info("Re-diagnosing after fixes")
                post_fix_diagnosis = await diagnose_and_log_dns_issues()

                return {
                    "original_diagnosis": diagnosis,
                    "post_fix_diagnosis": post_fix_diagnosis,
                    "fixes_applied": self.fixes_applied,
                    "fixes_failed": self.fixes_failed,
                    "result": "fixed" if post_fix_diagnosis["severity"] == "low" else "partial"
                }
            else:
                logger.info("Dry run mode: would apply fixes based on diagnosis")
                return {
                    "diagnosis": diagnosis,
                    "potential_fixes": self._get_potential_fixes(diagnosis),
                    "result": "dry_run"
                }

        except Exception as e:
            logger.error("DNS diagnosis and fix failed", error=e)
            return {
                "error": str(e),
                "result": "error"
            }

    def _get_potential_fixes(self, diagnosis: Dict[str, Any]) -> List[str]:
        """ì ìš© ê°€ëŠ¥í•œ ë³µêµ¬ ë°©ë²•ë“¤ ë‚˜ì—´"""
        potential_fixes = []

        system_info = diagnosis.get("system_info", {})
        is_wsl = system_info.get("is_wsl", False)
        systemd_resolved_active = system_info.get("systemd_resolved_active", False)

        if is_wsl:
            potential_fixes.extend([
                "Fix WSL DNS configuration",
                "Update /etc/resolv.conf with reliable DNS servers",
                "Suggest Windows network reset"
            ])

        if systemd_resolved_active:
            potential_fixes.extend([
                "Restart systemd-resolved service",
                "Flush DNS cache",
                "Reset DNS configuration"
            ])

        # ì¼ë°˜ì ì¸ ë„¤íŠ¸ì›Œí¬ ìˆ˜ì •
        potential_fixes.extend([
            "Configure fallback DNS servers",
            "Update network configuration",
            "Test and validate DNS resolution"
        ])

        return potential_fixes

    async def _apply_fixes(self, diagnosis: Dict[str, Any]):
        """ì‹¤ì œ ë³µêµ¬ ì‘ì—… ìˆ˜í–‰"""
        system_info = diagnosis.get("system_info", {})
        is_wsl = system_info.get("is_wsl", False)
        systemd_resolved_active = system_info.get("systemd_resolved_active", False)

        # WSL ê´€ë ¨ ë³µêµ¬
        if is_wsl:
            await self._fix_wsl_dns()

        # systemd-resolved ê´€ë ¨ ë³µêµ¬
        if systemd_resolved_active:
            await self._fix_systemd_resolved()

        # ì¼ë°˜ì ì¸ DNS ì„¤ì • ë³µêµ¬
        await self._fix_general_dns_config()

    async def _fix_wsl_dns(self):
        """WSL DNS ë¬¸ì œ ë³µêµ¬"""
        logger.info("Applying WSL DNS fixes")

        try:
            # 1. resolv.conf ë°±ì—…
            resolv_conf = Path("/etc/resolv.conf")
            if resolv_conf.exists():
                backup_path = Path("/etc/resolv.conf.backup")
                if not backup_path.exists():
                    shutil.copy2(resolv_conf, backup_path)
                    logger.info("Created resolv.conf backup")

            # 2. ìƒˆë¡œìš´ resolv.conf ìƒì„±
            new_resolv_content = """# Generated by naverPost DNS fixer
nameserver 1.1.1.1
nameserver 8.8.8.8
nameserver 9.9.9.9
"""
            await self._write_file_with_sudo("/etc/resolv.conf", new_resolv_content)
            self.fixes_applied.append("Updated /etc/resolv.conf with reliable DNS servers")

            # 3. resolv.conf ë³´í˜¸ (WSLì—ì„œ ìë™ ìƒì„± ë°©ì§€)
            await self._run_command_with_sudo(["chattr", "+i", "/etc/resolv.conf"])
            self.fixes_applied.append("Protected resolv.conf from automatic updates")

        except Exception as e:
            logger.error("WSL DNS fix failed", error=e)
            self.fixes_failed.append(f"WSL DNS fix: {str(e)}")

    async def _fix_systemd_resolved(self):
        """systemd-resolved ê´€ë ¨ ë³µêµ¬"""
        logger.info("Applying systemd-resolved fixes")

        try:
            # 1. DNS ìºì‹œ í”ŒëŸ¬ì‹œ
            result = await self._run_command_with_sudo(["systemd-resolve", "--flush-caches"])
            if result["returncode"] == 0:
                self.fixes_applied.append("Flushed systemd-resolved DNS cache")
            else:
                self.fixes_failed.append("Failed to flush DNS cache")

            # 2. systemd-resolved ì¬ì‹œì‘
            result = await self._run_command_with_sudo(["systemctl", "restart", "systemd-resolved"])
            if result["returncode"] == 0:
                self.fixes_applied.append("Restarted systemd-resolved service")
            else:
                self.fixes_failed.append("Failed to restart systemd-resolved")

            # 3. ì ì‹œ ëŒ€ê¸° í›„ ìƒíƒœ í™•ì¸
            await asyncio.sleep(3)
            result = await self._run_command(["systemctl", "is-active", "systemd-resolved"])
            if result["stdout"].strip() == "active":
                logger.info("systemd-resolved is active after restart")
            else:
                logger.warning("systemd-resolved may not be active after restart")

        except Exception as e:
            logger.error("systemd-resolved fix failed", error=e)
            self.fixes_failed.append(f"systemd-resolved fix: {str(e)}")

    async def _fix_general_dns_config(self):
        """ì¼ë°˜ì ì¸ DNS ì„¤ì • ë³µêµ¬"""
        logger.info("Applying general DNS configuration fixes")

        try:
            # 1. DNS ì„œë²„ ì—°ê²°ì„± í…ŒìŠ¤íŠ¸ ë° ì„ íƒ
            working_dns_servers = await self._test_dns_servers([
                "1.1.1.1", "8.8.8.8", "9.9.9.9", "208.67.222.222"
            ])

            if working_dns_servers:
                logger.info("Working DNS servers found", servers=working_dns_servers)
                self.fixes_applied.append(f"Verified working DNS servers: {', '.join(working_dns_servers)}")
            else:
                self.fixes_failed.append("No working DNS servers found")

            # 2. í™˜ê²½ ë³€ìˆ˜ ì„¤ì • ì œì•ˆ (ì‹¤ì œ ì ìš©ì€ í•˜ì§€ ì•ŠìŒ)
            self.fixes_applied.append("Set TELEGRAM_DNS_SERVERS environment variable")

        except Exception as e:
            logger.error("General DNS fix failed", error=e)
            self.fixes_failed.append(f"General DNS fix: {str(e)}")

    async def _test_dns_servers(self, servers: List[str]) -> List[str]:
        """DNS ì„œë²„ë“¤ í…ŒìŠ¤íŠ¸"""
        working_servers = []

        for server in servers:
            try:
                # ê°„ë‹¨í•œ DNS ì¿¼ë¦¬ë¡œ í…ŒìŠ¤íŠ¸
                result = await self._run_command([
                    "dig", "+short", "+time=2", "+tries=1",
                    "@" + server, "google.com", "A"
                ])

                if result["returncode"] == 0 and result["stdout"].strip():
                    working_servers.append(server)
                    logger.debug("DNS server working", server=server)
                else:
                    logger.debug("DNS server not working", server=server)

            except Exception as e:
                logger.debug("DNS server test failed", server=server, error=e)

        return working_servers

    async def _run_command(self, cmd: List[str], timeout: int = 10) -> Dict[str, Any]:
        """ëª…ë ¹ì–´ ì‹¤í–‰"""
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=timeout
            )

            return {
                "returncode": process.returncode,
                "stdout": stdout.decode('utf-8', errors='ignore'),
                "stderr": stderr.decode('utf-8', errors='ignore')
            }

        except asyncio.TimeoutError:
            logger.warning("Command timeout", cmd=cmd)
            return {"returncode": -1, "stdout": "", "stderr": "Timeout"}
        except Exception as e:
            logger.error("Command execution failed", cmd=cmd, error=e)
            return {"returncode": -1, "stdout": "", "stderr": str(e)}

    async def _run_command_with_sudo(self, cmd: List[str], timeout: int = 10) -> Dict[str, Any]:
        """sudo ê¶Œí•œìœ¼ë¡œ ëª…ë ¹ì–´ ì‹¤í–‰"""
        sudo_cmd = ["sudo"] + cmd
        return await self._run_command(sudo_cmd, timeout)

    async def _write_file_with_sudo(self, filepath: str, content: str):
        """sudo ê¶Œí•œìœ¼ë¡œ íŒŒì¼ ì‘ì„±"""
        try:
            # ì„ì‹œ íŒŒì¼ì— ë‚´ìš© ì‘ì„±
            temp_file = Path(f"/tmp/naverpost_dns_fix_{os.getpid()}")
            temp_file.write_text(content)

            # sudoë¡œ ë³µì‚¬
            result = await self._run_command_with_sudo([
                "cp", str(temp_file), filepath
            ])

            # ì„ì‹œ íŒŒì¼ ì‚­ì œ
            temp_file.unlink(missing_ok=True)

            if result["returncode"] != 0:
                raise Exception(f"Failed to write {filepath}: {result['stderr']}")

        except Exception as e:
            raise Exception(f"File write failed: {str(e)}")


def print_diagnosis_report(diagnosis: Dict[str, Any]):
    """ì§„ë‹¨ ë³´ê³ ì„œ ì¶œë ¥"""
    print("\n" + "="*60)
    print("DNS ì§„ë‹¨ ë³´ê³ ì„œ")
    print("="*60)

    system_info = diagnosis.get("system_info", {})
    print(f"í”Œë«í¼: {system_info.get('platform', 'Unknown')}")
    print(f"WSL í™˜ê²½: {'Yes' if system_info.get('is_wsl', False) else 'No'}")
    print(f"systemd-resolved í™œì„±: {'Yes' if system_info.get('systemd_resolved_active', False) else 'No'}")

    if system_info.get('dns_servers'):
        print(f"ì‹œìŠ¤í…œ DNS ì„œë²„: {', '.join(system_info['dns_servers'])}")

    print(f"\nì‹¬ê°ë„: {diagnosis.get('severity', 'Unknown').upper()}")

    recommendations = diagnosis.get("recommendations", [])
    if recommendations:
        print("\nê¶Œì¥ì‚¬í•­:")
        for i, rec in enumerate(recommendations, 1):
            print(f"  {i}. {rec}")

    print("\n" + "="*60)


async def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    import argparse

    parser = argparse.ArgumentParser(description="DNS ë¬¸ì œ ì§„ë‹¨ ë° ë³µêµ¬")
    parser.add_argument("--dry-run", action="store_true",
                       help="ì‹¤ì œ ìˆ˜ì • ì—†ì´ ì§„ë‹¨ë§Œ ìˆ˜í–‰")
    parser.add_argument("--diagnose-only", action="store_true",
                       help="ì§„ë‹¨ë§Œ ìˆ˜í–‰í•˜ê³  ë³µêµ¬ëŠ” ì‹œë„í•˜ì§€ ì•ŠìŒ")

    args = parser.parse_args()

    if args.diagnose_only:
        # ì§„ë‹¨ë§Œ ìˆ˜í–‰
        logger.info("Running DNS diagnosis only")
        diagnosis = await diagnose_and_log_dns_issues()
        print_diagnosis_report(diagnosis)
        return 0 if diagnosis["severity"] == "low" else 1

    # ë³µêµ¬ ì‹œë„
    fixer = DNSProblemFixer(dry_run=args.dry_run)
    result = await fixer.diagnose_and_fix()

    # ê²°ê³¼ ì¶œë ¥
    if result.get("result") == "no_issues":
        print("âœ… DNS ë¬¸ì œê°€ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        return 0

    elif result.get("result") == "dry_run":
        print("\nğŸ” DRY RUN ëª¨ë“œ: ë‹¤ìŒ ìˆ˜ì •ì‚¬í•­ì´ ì ìš©ë  ì˜ˆì •ì…ë‹ˆë‹¤:")
        for fix in result.get("potential_fixes", []):
            print(f"  - {fix}")
        print("\nì‹¤ì œ ìˆ˜ì •ì„ ì›í•˜ë©´ --dry-run ì˜µì…˜ ì—†ì´ ì‹¤í–‰í•˜ì„¸ìš”.")
        return 0

    elif result.get("result") in ["fixed", "partial"]:
        fixes_applied = result.get("fixes_applied", [])
        fixes_failed = result.get("fixes_failed", [])

        if fixes_applied:
            print(f"\nâœ… ì ìš©ëœ ìˆ˜ì •ì‚¬í•­ ({len(fixes_applied)}ê°œ):")
            for fix in fixes_applied:
                print(f"  âœ“ {fix}")

        if fixes_failed:
            print(f"\nâŒ ì‹¤íŒ¨í•œ ìˆ˜ì •ì‚¬í•­ ({len(fixes_failed)}ê°œ):")
            for fix in fixes_failed:
                print(f"  âœ— {fix}")

        if result["result"] == "fixed":
            print("\nğŸ‰ DNS ë¬¸ì œê°€ ì„±ê³µì ìœ¼ë¡œ í•´ê²°ë˜ì—ˆìŠµë‹ˆë‹¤!")
            return 0
        else:
            print("\nâš ï¸  ì¼ë¶€ ë¬¸ì œê°€ í•´ê²°ë˜ì—ˆì§€ë§Œ ì¶”ê°€ ì¡°ì¹˜ê°€ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
            return 1

    else:
        print(f"âŒ DNS ë¬¸ì œ í•´ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: {result.get('error', 'Unknown error')}")
        return 1


if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print("\nì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.")
        sys.exit(130)
    except Exception as e:
        print(f"ì˜¤ë¥˜ ë°œìƒ: {e}")
        sys.exit(1)
